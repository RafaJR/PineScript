//@version=5
strategy(title="3AverangeSystem", shorttitle="3AverangeSystem", overlay=true, pyramiding=0, calc_on_order_fills=false, commission_type=strategy.commission.percent, commission_value=0.25, default_qty_type=strategy.percent_of_equity, default_qty_value=100, initial_capital=100, currency=currency.USD, slippage = 175)

// 1h - Kraken - Ethereum / U.S. Dollar

// Colors for both moving averages
colorLong = #00ff08  // Green for bullish movements
colorShort = #ff0000 // Red for bearish movements
fillColorLong = color.new(colorLong, 70)
fillColorShort = color.new(colorShort, 70)
fillBullishDivergenceColor = color.new(colorLong, 90)
fillBearishDivergenceColor = color.new(colorShort, 90)
hidden = color.new(color.black, 100)

// General inputs
source = input.source(defval=close, title="Prize data source", group="General configuration")
maxFractals = input.int(defval=20, minval=2, maxval=50, title="Max fractals storage", group="General configuration")
maxSRLimits = input.int(defval=20, minval=2, maxval=50, title="Max support/resisteance limits", group="General configuration")

// StopLoss / TakeProffit percents
stopLossPercent = input.float(defval=1, title="Porcentaje de Stop Loss (%)", group="Risk control", step=0.1)
takeProfitPercent = input.float(defval=22, title="Porcentaje de Take Profit (%)", group="Risk control", step=1)

// Prize support or resisteance magin
srMargin = input.float(defval=5, title = "Prize support or resisteance magin", group="Risk control")

// Time parameters for testing
currentYear = input.int(defval=2015, title="Year", step=1, group = "Time")
currentMonth = input.int(defval=1, title="Month", step=1, group = "Time")

// Averange calculation parameters
maType = input.string("VWMA", "Basis MA Type", options = ["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="Averange")
int averangeLength = input.int(defval=5, title="Averange", group="Averange", step=1)
int averangeSlowLength = input.int(defval=8, title="Averange", group="Slow averange", step=1)

//***************************************************************************************************************************************************************
// General funtions
//***************************************************************************************************************************************************************


//***************************************************************************************************************************************************************
// Chart calculations 
//***************************************************************************************************************************************************************
maSource(float source, int length, simple string maType) =>
    switch maType
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "SMMA (RMA)" => ta.rma(source, length)
        "WMA" => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)

float maSource = maSource(source, averangeLength, maType)
float maSourceSlow = maSource(source, averangeSlowLength, maType)
float mahl2 = maSource(hl2, averangeLength, maType)
float maHigh = maSource(high, averangeLength, maType)
float maLow = maSource(low, averangeLength, maType)



//***************************************************************************************************************************************************************
// Chart printing 
//***************************************************************************************************************************************************************
maSourceSlowColor = maSourceSlow < source ? colorLong : colorShort
maSourceSlowPlot = plot(series=maSourceSlow, title="maSource", color=maSourceSlowColor, linewidth = 2)
//maHL2Plot = plot(series=mahl2, title="maSource", color=color.yellow, linewidth = 1)
maHighPlot = plot(series=maHigh, title="maHigh", color=hidden, linewidth = 1)
maLowPlot = plot(series=maLow, title="maLow", color=hidden, linewidth = 1)

fillColor = maSource > mahl2 ? fillColorLong : fillColorShort
fill(maHighPlot, maLowPlot, color=fillColor, fillgaps=true)

//***************************************************************************************************************************************************************
// Operation orders
//***************************************************************************************************************************************************************
// Entry vars inicialization
var bool killLongEntry = false
var bool killShortEntry = false
var bool longEntry = false
var bool shortEntry = false
var bool operationalBusy = false

// Entry conditions
longEntry := maSource > mahl2 and  source > maSourceSlow 
//killLongEntry :=  maSource < mahl2
shortEntry := maSource < mahl2 and source < maSourceSlow
//killShortEntry := maSource > mahl2

// Time parameters for testing
//if (year == 2025 and month == 1 and dayofmonth >= 6 and dayofmonth <= 7)
//if (year == currentYear and month == currentMonth)
//if (year == currentYear)
if (true)
    // Operation nomenclature variables
    var int longOpCount = 0
    var int shortOpCount = 0
    var string longOpName = ""
    var string shortOpName = ""

    if(killLongEntry)
        strategy.close(id=longOpName)
        operationalBusy := false
    if(killShortEntry)
        strategy.close(id=shortOpName)
        operationalBusy := false
    if (longEntry and not operationalBusy)
        longOpCount += 1
        longOpName := "Long"
        longOpComment = longOpName + str.tostring(longOpCount)
        strategy.entry(id=longOpName, direction=strategy.long, comment=longOpComment)
        stopLossPrize = strategy.position_avg_price * (1 - takeProfitPercent / 100)
        takeProfitPrize = strategy.position_avg_price * (1 + takeProfitPercent / 100)
        strategy.exit(id=longOpName, from_entry=longOpName, comment=longOpComment, stop=stopLossPrize, limit=takeProfitPrize, comment_profit = "TakeProffit" + str.tostring(longOpCount), comment_loss = "SL" + str.tostring(longOpCount))
        //strategy.exit(id=longOpName, from_entry=longOpName, comment=longOpComment, stop=stopLossPrize, comment_profit = "PROFIT" + str.tostring(longOpCount))
        operationalBusy := true
    if (shortEntry and not operationalBusy)
        shortOpCount += 1
        shortOpName := "Short"
        shortOpComment = shortOpName + str.tostring(shortOpCount)
        strategy.entry(id=shortOpName, direction=strategy.short, comment=shortOpComment)
        stopLossPrize = strategy.position_avg_price * (1 + takeProfitPercent / 100)
        takeProfitPrize = strategy.position_avg_price * (1 - takeProfitPercent / 100)
        strategy.exit(id=shortOpName, from_entry=shortOpName, comment=shortOpComment, stop=stopLossPrize, limit=takeProfitPrize, comment_profit = "TP" + str.tostring(shortOpCount), comment_loss = "SL" + str.tostring(longOpCount))
        //strategy.exit(id=shortOpName, from_entry=shortOpName, comment=shortOpComment, stop=stopLossPrize, comment_profit = "PROFIT" + str.tostring(shortOpCount))
        operationalBusy := true
    if (strategy.position_size == 0)
        operationalBusy := false
    // Stop Loss update
    if (operationalBusy)
        bool isLongActive = strategy.position_size > 0
        bool isShortActive = strategy.position_size < 0

        //if (isLongActive and sarBecomeBullish)
        //    strategy.exit(id=longOpName, from_entry=longOpName, stop=currentLowest, comment_profit = "DTP" + str.tostring(longOpCount), comment_loss = "DSL" + str.tostring(longOpCount))
        //if (isShortActive and sarBecomeBearish)
        //    strategy.exit(id=shortOpName, from_entry=shortOpName, stop=currentHighest, comment_profit = "DTP" + str.tostring(longOpCount), comment_loss = "DSL" + str.tostring(longOpCount))
        //if (isLongActive and not longEntrySustainable)
        //    strategy.exit(id=longOpName, from_entry=longOpName, profit=currentHighest, comment_profit = "DTP" + str.tostring(longOpCount), comment_loss = "DSL" + str.tostring(longOpCount))
        //if (isShortActive and not shortEntrySustainable)
        //    strategy.exit(id=shortOpName, from_entry=shortOpName, profit=currentLowest, comment_profit = "DTP" + str.tostring(longOpCount), comment_loss = "DSL" + str.tostring(longOpCount))